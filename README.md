# kanoma-build-image
<img align="left" width="200" height="200" alt="image" src="https://github.com/user-attachments/assets/72cca1bc-14e9-4e4b-b9f2-217a1bcae610" />

<p align="right">
   <strong>Status: B√™ta</strong>
   <br />
   <strong>Version: </strong>0.0.1
   <br />
   <br />
   Ce projet a pour but de construire des images de machines virtuelles (VM) pour Google Cloud Platform (GCP) de mani√®re automatis√©e, reproductible et valid√©e, en utilisant un pipeline CI/CD avec GitHub Actions.
   <br />
   - **Automatisation** : Construire des images sans intervention manuelle.
   - **Standardisation** : S'assurer que toutes les images sont bas√©es sur une configuration commune et valid√©e.
   - **Validation** : Tester chaque image apr√®s sa construction pour garantir sa conformit√©.
   - **S√©curit√©** : Utiliser des m√©thodes d'authentification modernes et s√©curis√©es (Workload Identity Federation).
  </p>
</p>
</br>



## Objectifs


---

## 1. Composants Principaux

Notre pipeline s'articule autour de plusieurs outils cl√©s :

| Outil | R√¥le |
| :--- | :--- |
| **Packer** | L'outil principal qui orchestre la cr√©ation de l'image sur GCP. |
| **Ansible** | Le provisioner utilis√© par Packer pour configurer la VM (installer Nginx, etc.). |
| **Goss** | Un outil rapide de validation de serveur bas√© sur du YAML pour tester l'image. |
| **GitHub Actions** | L'orchestrateur CI/CD qui ex√©cute les diff√©rentes √©tapes du processus. |

---

## üöÄ D√©mo Live : Lancez votre propre build !

Cette section vous guide pour d√©clencher manuellement la cr√©ation d'une image.

### Pr√©requis pour la d√©mo

1.  **Acc√®s au projet GCP** : Assurez-vous d'avoir un projet GCP configur√©.
2.  **Service Account & WIF** : Le Service Account `sa-buildimage` et la f√©d√©ration d'identit√© (Workload Identity Federation) doivent √™tre configur√©s comme d√©crit dans la section "Authentification GCP".
3.  **APIs GCP activ√©es** : L'API `Compute Engine` doit √™tre activ√©e sur votre projet.

### √âtapes de la d√©mo
1.  **Cliquez ici pour lancer le workflow üëâ [![Ex√©cuter le workflow de build](https://github.com/romaincapelle-kanoma/kanoma-build-image/actions/workflows/build.yml/badge.svg?branch=main&event=workflow_dispatch&query=machine_type%3Arhel-9)](https://github.com/romaincapelle-kanoma/kanoma-build-image/actions/workflows/build.yml)

2.  Cliquez sur le bouton **"Run workflow"**.

3.  **Remplissez les options** comme souhait√© :
    *   **`project_id`**: L'ID de votre projet GCP.
    *   **`machine_type`**: Choisissez `rhel-9` ou `rhel-8`.
    *   **`validate`**: Cochez cette case pour lancer la phase de test apr√®s le build. **(Recommand√© pour la d√©mo !)**

4.  Cliquez sur **"Run workflow"** pour d√©marrer.

### Quoi suivre pendant la d√©mo ?

*   **Dans GitHub Actions** :
    1.  Le job `build` d√©marre, s'authentifie sur GCP.
    2.  Les logs de Packer montrent la cr√©ation de la VM temporaire.
    3.  Les logs d'Ansible affichent la configuration de Nginx.
    4.  Le job `validate` d√©marre (si activ√©).

*   **Dans la console GCP (Projet cible)** :
    1.  **(Pendant le build)** Allez dans `Compute Engine > Instances de VM`. Vous verrez une instance temporaire nomm√©e `packer-xxxx`. Elle sera supprim√©e automatiquement √† la fin du build.
    2.  **(Apr√®s le build)** Allez dans `Compute Engine > Images`. Vous trouverez votre nouvelle image, nomm√©e `rhel-9-nginx-timestamp` (par exemple).
    3.  **(Pendant la validation)** Une instance `test-xxxx` est cr√©√©e √† partir de votre nouvelle image. Les tests Goss s'ex√©cutent dessus, puis elle est supprim√©e.

---

## 2. Diagramme du Pipeline

```mermaid
graph TD
    subgraph "D√©clencheurs"
        A[üë®‚Äçüíª Manuel via workflow_dispatch]
        B[üïí Planifi√© via schedule]
    end

    subgraph "GitHub Actions"
        C(build.yml)
        A & B --> C

        subgraph "Job: build"
            D[1. Auth GCP via WIF] --> E[2. Packer Build]
            E --> F{VM temporaire}
            F -- provision --> G[Ansible: installe Nginx]
            G -- cr√©e image --> H[‚úÖ Image GCP]
            F -- d√©truite --> E
        end

        subgraph "Job: validate (si activ√©)"
            I[1. Cr√©e VM de test] -- depuis --> H
            I --> J[2. Lance les tests Goss]
            J -- valide --> K{R√©sultat}
            I -- toujours d√©truite --> L[üèÅ Fin]
        end

        C --> D
        H --> I
    end
```

## 2. Fonctionnement du Pipeline de Build (`.github/workflows/build.yml`)

Le workflow principal est con√ßu pour √™tre √† la fois autonome et r√©utilisable. Il se d√©compose en deux phases (jobs) : `build` et `validate`.

### D√©clencheurs

Le workflow peut √™tre lanc√© de deux mani√®res :
1.  **Manuellement (`workflow_dispatch`)** : Via l'interface GitHub Actions, en choisissant le projet GCP, le type d'image (RHEL 8/9) et si la validation doit √™tre lanc√©e.
2.  **Par un autre workflow (`workflow_call`)** : Permet √† un workflow de planification (`schedule.yml`) de d√©clencher des builds nocturnes, par exemple.

### Phase 1 : Construction de l'image (`build`)

Ce job est responsable de la cr√©ation de l'image brute.

1.  **Authentification GCP** : Le workflow s'authentifie sur GCP de mani√®re s√©curis√©e sans utiliser de cl√© de service JSON. Il utilise **Workload Identity Federation**, o√π GitHub est approuv√© comme fournisseur d'identit√© pour un Service Account GCP.
    
    **D√©tail du fonctionnement de Workload Identity Federation (WIF)** :
    Workload Identity Federation est un m√©canisme de s√©curit√© qui permet √† des identit√©s externes (comme GitHub Actions) d'assumer l'identit√© d'un Service Account GCP sans avoir √† t√©l√©charger et g√©rer des cl√©s de service statiques.
    -   **√âmission du jeton OIDC** : Lors de l'ex√©cution du workflow GitHub Actions, GitHub g√©n√®re un jeton OpenID Connect (OIDC). Ce jeton est sign√© par GitHub et contient des informations v√©rifiables sur l'identit√© du workflow (par exemple, le d√©p√¥t, l'organisation, le nom du workflow).
    -   **√âchange avec GCP** : Le workflow utilise ce jeton OIDC pour s'authentifier aupr√®s d'un **Pool d'Identit√©s de Charge de Travail (Workload Identity Pool)** configur√© dans GCP.
    -   **V√©rification et confiance** : GCP v√©rifie la signature du jeton OIDC et s'assure que l'√©metteur (GitHub) est un fournisseur d'identit√© de confiance configur√© dans le pool.
    -   **Attribution du r√¥le de Service Account** : Si la v√©rification est r√©ussie, GCP permet au workflow d'assumer l'identit√© du Service Account sp√©cifi√© (`sa-buildimage@${{ inputs.project_id }}.iam.gserviceaccount.com`).
    -   **Jeton d'acc√®s temporaire** : En retour, GCP fournit un jeton d'acc√®s OAuth 2.0 de courte dur√©e. Ce jeton permet au workflow d'interagir avec les services GCP en utilisant les permissions du Service Account, sans jamais exposer de cl√©s de longue dur√©e.
    
    **Pr√©requis pour le Service Account GCP (`sa-buildimage`)** :
    Pour que le Service Account `sa-buildimage` puisse effectuer toutes les op√©rations n√©cessaires √† la construction et √† la validation des images (cr√©ation de VM temporaires, cr√©ation d'images, etc.), il doit disposer des r√¥les IAM (Identity and Access Management) suivants sur le projet GCP cible (`${{ inputs.project_id }}`) :
    -   `roles/compute.instanceAdmin.v1` : Permet de g√©rer (cr√©er, supprimer, etc.) les instances Compute Engine. N√©cessaire pour la VM de build de Packer et la VM de test de Goss.
    -   `roles/compute.imageUser` : Permet d'utiliser les images Compute Engine (n√©cessaire pour cr√©er la VM de build √† partir d'une image de base).
    -   `roles/iam.serviceAccountUser` : Permet au SA du pipeline (`sa-buildimage`) d'emprunter l'identit√© du Service Account attach√© √† la VM de build. C'est une bonne pratique de s√©curit√© pour que la VM elle-m√™me ait des permissions d√©finies.
    
    > **Note** : Ces r√¥les doivent √™tre attribu√©s sp√©cifiquement au Service Account `sa-buildimage@${{ inputs.project_id }}.iam.gserviceaccount.com` dans le projet GCP o√π les images seront construites.
        -   Cr√©er, d√©marrer, arr√™ter et supprimer les VM temporaires utilis√©es par Packer pour le build.
        -   Cr√©er, d√©marrer, arr√™ter et supprimer les VM de test utilis√©es pour la validation.
    
2.  **Initialisation de Packer** : La commande `packer init` t√©l√©charge les plugins n√©cessaires (`googlecompute`, `ansible`).
    > **Point cl√©** : On utilise un `PACKER_GITHUB_API_TOKEN: ${{ secrets.GITHUB_TOKEN }}` pour √©viter les erreurs de "rate limiting" de l'API GitHub.

3.  **Lancement du build Packer** : La commande `packer build` est ex√©cut√©e.
    - Packer d√©marre une VM temporaire sur GCP √† partir d'une image source (ex: `rhel-9-base`).
    - Une fois la VM d√©marr√©e, Packer se connecte en SSH et lance le playbook **Ansible** (`play_host_rhel_build.yml`).
    - Ansible installe et configure Nginx, cr√©e la page `index.html` et s'assure que le service est d√©marr√©.
    - Une fois le provisionning termin√©, Packer cr√©e une image (snapshot) de la VM configur√©e.
    - La VM temporaire est d√©truite.

4.  **R√©cup√©ration du nom de l'image** : Le nom de l'image finale, g√©n√©r√© par Packer, est extrait du fichier `manifest.json` et pass√© en output pour la phase suivante.

### Phase 2 : Validation de l'image (`validate`)

Ce job ne s'ex√©cute que si l'option `validate` est activ√©e. Il garantit que l'image construite est conforme √† nos attentes.

1.  **Cr√©ation d'une instance de test** : Une nouvelle VM est cr√©√©e sur GCP, cette fois-ci en utilisant **l'image que nous venons de construire**.

2.  **Ex√©cution des tests Goss** :
    - L'ex√©cutable `goss` est t√©l√©charg√© sur l'instance de test.
    - Le fichier de d√©finition des tests (`tests/goss.yaml`) est copi√© sur l'instance.
    - `goss` est ex√©cut√© sur l'instance. Il valide l'√©tat du serveur en se basant sur les r√®gles d√©finies dans le fichier YAML :
        - Le paquet `nginx` est-il install√© ?
        - Le service `nginx` est-il d√©marr√© et activ√© ?
        - Le port `80` est-il en √©coute ?
        - Le fichier `index.html` a-t-il le bon contenu et les bonnes permissions ?
    - Si un de ces tests √©choue, le workflow √©choue.

3.  **Nettoyage** : L'√©tape `Cleanup test instance` s'ex√©cute **toujours** (`if: always()`), m√™me si les tests ont √©chou√©. Elle supprime la VM de test pour √©viter de laisser des ressources orphelines et de g√©n√©rer des co√ªts inutiles.

---

## 3. Builds Planifi√©s (`.github/workflows/schedule.yml`)

Pour garantir que nos images de base sont toujours √† jour (par exemple, avec les derniers patchs de s√©curit√© inclus dans l'image source), un second workflow est en place.

- Il se d√©clenche sur un `schedule` (ex: tous les dimanches √† 3h du matin).
- Il ne contient aucune logique de build. Son seul r√¥le est d'appeler le workflow `build.yml` (une fois pour RHEL 8, une fois pour RHEL 9).
- Il force l'activation de la validation (`validate: true`), car il est crucial que les builds automatis√©s soient test√©s.

Cette s√©paration des pr√©occupations rend le syst√®me plus modulaire et facile √† maintenir.

---

## 5. Structure du D√©p√¥t

```
‚îú‚îÄ‚îÄ .github/workflows/
‚îÇ   ‚îú‚îÄ‚îÄ build.yml         # Workflow principal de build et validation
‚îÇ   ‚îî‚îÄ‚îÄ schedule.yml      # Workflow pour les builds planifi√©s (cron)
‚îú‚îÄ‚îÄ ansible/
‚îÇ   ‚îî‚îÄ‚îÄ play_host_rhel_build.yml # Playbook pour configurer Nginx
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îú‚îÄ‚îÄ rhel-8/           # Fichiers de configuration Packer pour RHEL 8
‚îÇ   ‚îî‚îÄ‚îÄ rhel-9/           # Fichiers de configuration Packer pour RHEL 9
‚îî‚îÄ‚îÄ tests/
    ‚îî‚îÄ‚îÄ goss.yaml         # Fichier de d√©finition des tests de validation
```
